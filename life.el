;;; life.el --- Description -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2021 Rafael Luque
;;
;; Author: Rafael Luque <https://github.com/luque>
;; Maintainer: Rafael Luque
;; Created: May 11, 2021
;; Modified: May 11, 2021
;; Version: 0.0.1
;; Keywords: games, experiments
;; Homepage: https://github.com/luque/life-elisp-smalltalk
;; Package-Requires: ((emacs "24.3"))
;;
;; This file is not part of GNU Emacs.
;;
;;;  Description:
;;
;; An experiment to use Pharo Smalltalk from Emacs Lisp using the
;; John Horton Conway's "Life" cellular automaton as example.
;;
;; The game's logic is implemented in Emacs Lisp, but optionally
;; the game's board can be showed using Pharo Smalltalk code
;; that is generated by the Emacs Lisp program.
;;
;;; Commentary:
;;
;;; Code:

(require 'cl-lib)
(require 'cl-seq)
(require 'dash)
(require 'pharo)

(defvar run-my-tests)

(defun cell-alive-p (cell generation)
  "CELL is alive when it is an element of the GENERATION."
  (if (member cell generation) t nil))

(defun cell-dead-p (cell generation)
  "CELL is dead when it is not an element of the GENERATION."
  (not (cell-alive-p cell generation)))

(defun neighbours (cell)
  "Neighbours of a given CELL."
  (let ((x (car cell))
        (y (cadr cell)))
    (list
     (list (- x 1) (- y 1)) (list x (- y 1)) (list (+ x 1) (- y 1))
     (list (- x 1) y) (list (+ x 1) y)
     (list (- x 1) (+ y 1)) (list x (+ y 1)) (list (+ x 1) (+ y 1))
     )
    )
  )

(defun num-alive-neighbours (cell generation)
  "Count how many CELL's neighbours are alive in the GENERATION."
  (let ((neighbours (neighbours cell)))
    (length
     (cl-remove-if-not (lambda (e) (cell-alive-p e generation)) neighbours))))

(defun die-by-underpopulation-p (cell generation)
  "A live CELL should die by underpopulation if GENERATION contains fewer than two live neighbours."
  (and (cell-alive-p cell generation)
       (< (num-alive-neighbours cell generation) 2)))

(defun die-by-overpopulation-p (cell generation)
  "A live CELL should die by overpopulation if GENERATION contains more than three live neighbours."
  (and (cell-alive-p cell generation)
       (> (num-alive-neighbours cell generation) 3)))

(defun survive-p (cell generation)
  "A live CELL should survive if GENERATION contains two or three live neighbours."
  (and (cell-alive-p cell generation)
       (or (= (num-alive-neighbours cell generation) 2)
           (= (num-alive-neighbours cell generation) 3))))

(defun birth-p (cell generation)
  "A dead CELL should birth if GENERATION contains exactly three live neighbours."
  (and (cell-dead-p cell generation)
       (= (num-alive-neighbours cell generation) 3)))

(defun born-cells (width height generation)
   "Dead cells in the current GENERATION that will born in the next generation."
  (cl-remove-if-not (lambda (pos) (birth-p pos generation)) (board width height))
)

(defun surviving-cells (width height generation)
   "Live cells in the current GENERATION that will survive in the next generation."
   (cl-remove-if-not (lambda (pos) (survive-p pos generation)) (board width height))
)

(defun board (columns rows)
  "Creates a set of cells for the WIDTH and HEIGHT specified."
  (let ((game (list '())))
    (dotimes (row rows)
      (dotimes (column columns)
        (push (list row column) game)
        ))
    (remove nil game))
)

(defun next-generation (width height generation)
  "Next generation for a given GENERATION of Game of Life."
  (append
   (born-cells width height generation)
   (surviving-cells width height generation))
)

;; State
(defvar current-generation)
(defvar width 10)
(defvar height 10)
(defconst rowHeight 20)
(defconst columnWidth 20)
(defconst default-delay 0.5)
(defconst wait-for-pharo-period 2)

;; Game functions
(defun conway (width height &optional delay)
  "Run Conway's Life simulation."
  (interactive "p")
  (setq width width)
  (setq height width)
  (or delay (setq delay default-delay))
  (life-setup)
  (while t
      (render-generation)
      (sit-for delay)
      (set-next-generation))
)

(defun life-setup ()
  (view-setup)
  (setq current-generation (first-generation))
)

(defun view-setup ()
  (emacs-view-setup)
  (pharo-view-setup)
)

(defun emacs-view-setup ()
  (switch-to-buffer
   (get-buffer-create
    (format "*Conway's Life [%dx%d]*" width height)) t)
  (life-mode)
)

(defun pharo-view-setup ()
  (pharo-setup)
  (new-morph "LifeMorph" "Life" '("columns" "rows" "contents") '())
  (add-class-method
   "LifeMorph"
   "rows: rowCount columns: columnCount"
   "^ self new
        rows: rowCount columns: columnCount;
	yourself"
   "instance creation")
  (add-method
   "LifeMorph"
   "rows: rowCount columns: columnCount"
   "rows := rowCount.
    columns := columnCount.
    contents := Array2D rows: rowCount columns: columnCount element: 0"
   "initialization")
  (add-method
   "LifeMorph"
   "contents: anArray2D"
   "contents := anArray2D.
    self changed."
   "initialization")
  (add-method
   "LifeMorph"
   "drawOn: canvas"
   "
	| cellWidth cellHeight rectangle cellColor cellValue |
	cellWidth := self width / columns.
	cellHeight := self height / rows.
	1 to: rows do: [ :row |
		1 to: columns do: [ :column |
			cellValue := contents at: row at: column.
			cellColor := cellValue = 1
				             ifTrue: [ Color black ]
				             ifFalse: [ Color white ].
			rectangle := Rectangle
				             left: self bounds left + (column - 1 * cellWidth)
				             right:
				             self bounds left + (column - 1 * cellWidth)
				             + cellWidth
				             top: self bounds top + (row - 1 * cellHeight)
				             bottom:
				             self bounds top + (row - 1 * cellHeight) + cellHeight.

			cellValue = 1
				ifTrue: [ canvas fillRectangle: rectangle color: cellColor ]
				ifFalse: [
					canvas
						frameAndFillRectangle: rectangle
						fillColor: Color white
						borderWidth: 1
						borderColor: Color black ] ] ].
	^ self"
   "drawing")
  (open-view-in-pharo)
)

(defun pharo-setup ()
  (setup-pharo-environment)
  (load-repl-server)
  (launch-pharo-repl)
  (sit-for wait-for-pharo-period t)
)

(defun open-view-in-pharo ()
  (eval-pharo
   (format
    "(LifeMorph rows: %d columns: %d)
        width: %d;
        height: %d;
	openInWorld."
    height
    width
    (* width columnWidth)
    (* height rowHeight)
    )
   )
)

(define-derived-mode life-mode special-mode "Life"
  "Major mode for the buffer of `life'."
  (setq-local show-trailing-whitespace nil)
  (setq-local truncate-lines t)
  (buffer-disable-undo))

(defun render-generation ()
  (render-emacs)
  (render-pharo)
)

(defun render-emacs ()
  (let ((inhibit-read-only t))
    (erase-buffer)
    (insert-rectangle
     (rectangle width height current-generation)))
)

(defun render-pharo ()
  (eval-pharo
   (format
    "LifeMorph allInstances first contents: %s"
    (asArray2D current-generation)))
)

(defun asArray2D (generation)
  ;; ((Array2D rows: 4 columns: 4 element: 0)
  ;;  	at: 1 at: 2 put: 1;
  ;; 	at: 2 at: 3 put: 1;
  ;; 	yourself)
  (let ((expression (format "((Array2D rows: %d columns: %d element: 0) " height width)))
    (concat
     expression
     (message "%s"
              (mapconcat
               (lambda(cell) (format "at: %d at: %d put: 1; " (+ 1 (car cell)) (+ 1 (cadr cell))))
               generation
               ""))
     "yourself)")
    )
)

(defun set-next-generation ()
  (setq current-generation
        (next-generation width height current-generation))
)

(defun first-generation ()
  '(      (0 1)
                (1 2)
    (2 0) (2 1) (2 2))
)

(defun rectangle (width height generation)
  (setq generation-rectangle '())
  (dotimes (row height)
    (let ((row-characters ""))
      (dotimes (column width)
        (if (cell-alive-p (list row column) generation)
            (setq row-characters (concat row-characters "X"))
            (setq row-characters (concat row-characters " "))))
      (add-to-list 'generation-rectangle row-characters t (lambda (e1 e2) nil))
      )
    )
  generation-rectangle
)

;; Unit Tests

(defun is-cell-alive ()
  "Test if a cell is alive."
  (let ((cell '(0 0))
        (generation '((0 0) (0 1))))
    (cl-assert (cell-alive-p cell generation)))
  (let ((cell '(0 1))
        (generation '((0 0) (0 1))))
    (cl-assert (cell-alive-p cell generation)))
  (let ((cell '(0 3))
        (generation '((0 0) (0 1))))
    (cl-assert (not (cell-alive-p cell generation))))
)

(defun is-cell-dead ()
  "Test if a cell is dead."
  (let ((cell '(0 3))
        (generation '((0 0) (0 1))))
    (cl-assert (cell-dead-p cell generation)))
  (let ((cell '(0 0))
        (generation '((0 0) (0 1))))
    (cl-assert (not (cell-dead-p cell generation))))
  (let ((cell '(0 1))
        (generation '((0 0) (0 1))))
    (cl-assert (not (cell-dead-p cell generation))))
)

(defun count-alive-neighbours ()
  "Count the number of live neighbours."
  (let ((cell '(1 1))
        (generation '((0 0) (0 1) (0 2)
                      (1 0) (1 1) (1 2)
                      (2 0) (2 1) (2 2))))
    (cl-assert (eq (num-alive-neighbours cell generation) 8)))
  (let ((cell '(0 0))
        (generation '((0 0) (0 1) (0 2)
                      (1 0) (1 1) (1 2)
                      (2 0) (2 1) (2 2))))
    (cl-assert (eq (num-alive-neighbours cell generation) 3)))
  (let ((cell '(0 3))
        (generation '((0 0) (0 1) (0 2)
                      (1 0) (1 1) (1 2)
                      (2 0) (2 1) (2 2))))
    (cl-assert (eq (num-alive-neighbours cell generation) 2)))
  (let ((cell '(0 4))
        (generation '((0 0) (0 1) (0 2)
                      (1 0) (1 1) (1 2)
                      (2 0) (2 1) (2 2))))
    (cl-assert (eq (num-alive-neighbours cell generation) 0)))
)

;; Game of Life's Rules:
;;
;;      Any live cell with fewer than two live neighbours dies, as if by underpopulation.
;;      Any live cell with two or three live neighbours lives on to the next generation.
;;      Any live cell with more than three live neighbours dies, as if by overpopulation.
;;      Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.

(defun should-die-by-underpopulation ()
  "Checks the predicate die-by-underpopulation-p."
  (let ((cell '(1 1))
        (generation '((1 1))))
    (cl-assert (die-by-underpopulation-p cell generation)))
  (let ((cell '(1 1))
        (generation '((0 0) (1 1))))
    (cl-assert (die-by-underpopulation-p cell generation)))
)

(defun should-die-by-overpopulation ()
  "Checks the predicate die-by-overpopulation-p."
  (let ((cell '(1 1))
        (generation '((0 0) (0 1) (0 2)
                      (1 0) (1 1))))
    (cl-assert (die-by-overpopulation-p cell generation)))
  (let ((cell '(1 1))
        (generation '((0 0) (0 1) (0 2)
                      (1 0) (1 1) (1 2))))
    (cl-assert (die-by-overpopulation-p cell generation)))
)

(defun should-survive ()
  "Checks the predicate survive-p."
  (let ((cell '(1 1))
        (generation '((0 0) (0 1)
                            (1 1))))
    (cl-assert (survive-p cell generation)))
  (let ((cell '(1 1))
        (generation '((0 0) (0 1) (0 2)
                            (1 1) )))
    (cl-assert (survive-p cell generation)))
)

(defun should-birth ()
  "Checks the predicate birth-p."
  (let ((cell '(1 1))
        (generation '((0 0) (0 1) (0 2))))
    (cl-assert (birth-p cell generation)))
  (let ((cell '(1 1))
        (generation '((0 0)
                      (1 0)
                      (2 0))))
        (cl-assert (birth-p cell generation)))
  )

(defun set-equal (set1 set2)
  "Returns t if both sets have the same elements."
  (not (-difference set1 (-intersection set1 set2)))
)

(defun next-generations-for-glider ()
  "Checks the next generation for a GLIDER artifact as current generation."
  (let ((glider '(      (0 1)
                              (1 2)
                  (2 0) (2 1) (2 2))))
    (cl-assert (set-equal (next-generation 3 4 glider)
                   '(
                     (1 0)       (1 2)
                           (2 1) (2 2)
                           (3 1))))
    (cl-assert (set-equal
                (next-generation 4 3
                                 (next-generation 3 4 glider))
                '(
                                 (1 2)
                     (2 0)       (2 2)
                           (3 1) (3 2))))
    (cl-assert (set-equal
                (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4 glider)))
                '(
                           (1 1)
                                 (2 2)
                           (3 1) (3 2))))
    (cl-assert (set-equal
                (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4 glider))))
                '(

                                 (2 2)
                           (3 1) (3 2))))
    (cl-assert (set-equal
                (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4 glider)))))
                '(

                           (2 1) (2 2)
                           (3 1) (3 2))))
    (cl-assert (set-equal
                (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4
                                 (next-generation 3 4 glider))))))
                '(

                           (2 1) (2 2)
                           (3 1) (3 2))))

    )
)

(defun next-generations-for-blinker ()
  "Checks the next generation for a BLINKER artifact as current generation."
  (let ((blinker '((0 1)
                   (1 1)
                   (2 1))))
    (cl-assert (set-equal
                (next-generation 3 3 blinker)
                '((1 0) (1 1) (1 2))))
    (cl-assert (set-equal
                (next-generation 3 3 (next-generation 3 3 blinker))
                blinker))
    )
)


(eval-when-compile
  (setq run-my-tests t))

(when run-my-tests
  ;; unit tests
  (message "Running tests...")

  (is-cell-alive)
  (is-cell-dead)
  (count-alive-neighbours)
  (should-die-by-underpopulation)
  (should-die-by-overpopulation)
  (should-survive)
  (should-birth)
  (next-generations-for-glider)
  (next-generations-for-blinker)

  (message "All tests passed OK!")
)

(provide 'life)
;;; life.el ends here
